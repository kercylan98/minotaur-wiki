---
title: Actor 模型概述
description: 一切皆是 Actor，分布式并行计算模型
published: true
date: 2024-07-04T08:52:53.420Z
tags: 
editor: markdown
dateCreated: 2024-06-19T10:29:43.149Z
---

# 介绍
自从分布式计算（Distributed computing）被提出后，业界就广泛开始了对这种新计算模式的研究和应用。在分布式系统中，传统的多线程和锁机制常常带来复杂的并发问题和性能瓶颈。而 `Actor` 模型作为一种并发编程模型，为解决这些问题提供了一种新颖且有效的方法。

# 什么是 Actor 模型？
`Actor` 模型是一种数学模型，用于处理并发计算。它由 Carl Hewitt、Peter Bishop 和 Richard Steiger 于 1973 年提出。
该模型的核心思想是将计算单元抽象为 `Actor`，每个 `Actor` 是独立的实体，拥有自己的状态和行为，并且通过消息传递来进行通信。

`Actor` 模型主要有以下几个关键概念：
- 一个 `Actor` 是一个独立的计算单元，具有自己的状态、行为和消息队列。每个 `Actor` 只负责处理自己的消息，不直接共享状态，从而避免了传统并发编程中的竞争条件问题。
- `Actor` 之间的通信是通过消息传递实现的。每个 `Actor` 具有一个唯一的地址（或引用），其他 `Actor` 可以通过该地址向它发送消息。消息传递是异步的，这意味着发送方不需要等待消息被处理。
- 当一个 `Actor` 接收到一条消息时，它可以根据当前的状态和消息内容决定自己的行为。具体来说，一个 `Actor` 在接收到消息后可以执行以下操作：
  - 创建新的 `Actor`。
  - 发送消息给其他 `Actor`。
  - 修改自己的状态。
- 不可变状态：`Actor` 模型提倡使用不可变状态，这意味着 `Actor` 在处理消息时不会直接修改其他 `Actor` 的状态，而是通过消息传递来间接影响它们。

# Actor 模型的优势
`Actor` 模型在处理并发和分布式计算时具有以下几个优势：
- 简化并发控制：由于 `Actor` 之间不共享状态，并发控制变得更加简单，不需要使用复杂的锁机制来避免竞争条件。
- 可扩展性：`Actor` 模型天然支持分布式计算和负载均衡，可以轻松扩展以应对大规模并发请求。
- 容错性：通过消息传递和 `Actor` 的独立性，可以实现高容错性和自愈能力。某个 `Actor` 出现故障时，不会影响其他 `Actor` 的正常运行。
- 模块化：`Actor` 模型提倡将系统分解为独立的 `Actor`，每个 `Actor` 专注于特定的任务，从而实现高度模块化和松耦合的系统设计。

# Actor 模型在游戏领域的影响
在游戏开发领域，`Actor` 模型因其处理并发和分布式系统的优势，得到了广泛的应用和认可。

## 并发处理与高性能
- 在线游戏通常需要处理大量用户的并发请求，例如实时多人游戏。在传统的线程模型中，需要通过复杂的锁机制来管理共享资源，容易导致性能瓶颈和死锁问题。而在 `Actor` 模型中，每个游戏实体（例如玩家、NPC、物品等）可以独立地作为一个 `Actor`，避免了复杂的并发控制，从而提升了系统的响应速度和可靠性。

- 游戏中的任务可以被分解成多个独立的 `Actor`，每个 `Actor` 负责处理特定的任务，例如路径计算、碰撞检测和 AI 逻辑等。这样可以更好地利用多核处理器的并行计算能力，提高游戏的整体性能。

## 高可扩展性
- 在大规模多人在线游戏（MMO）中，玩家分布在不同的区域或服务器上。`Actor` 模型的消息传递机制使得动态负载均衡变得更加容易。例如，可以根据玩家的分布情况动态地调整服务器资源，将繁忙区域的负载分配到空闲服务器上，从而提升系统的可扩展性和稳定性。

- 游戏服务器通常采用分布式架构，以应对大量的并发连接和请求。`Actor` 模型的天然分布式特性使得游戏服务器可以更容易地扩展和维护。通过 `Actor` 之间的消息传递，可以实现跨服务器的通信和协作，提升系统的扩展能力。

## 容错与恢复
- 在游戏服务器中，硬件故障、网络问题和软件错误都是常见的挑战。`Actor` 模型通过将系统分解为独立的 `Actor`，可以实现更高的容错性。例如，当某个 `Actor` 发生故障时，可以通过消息机制自动重启或迁移到其他服务器，确保系统的稳定性和连续性。

- `Actor` 模型支持自愈能力，当某个 `Actor` 出现异常时，可以自动重启并恢复到正常状态。这样可以大大减少人为干预和系统停机时间，提高游戏服务器的可靠性和用户体验。

## 模块化与可维护性
- 游戏开发通常涉及大量的功能模块，例如物理引擎、AI 系统和网络通信等。`Actor` 模型提倡将每个功能模块独立为 `Actor`，从而实现高度模块化的设计。这样可以使得各个模块之间的耦合度降低，提升系统的可维护性和可扩展性。

- 通过 `Actor` 模型，可以实现代码的高度复用。例如，可以将通用的功能封装为独立的 `Actor`，并在不同的游戏场景中重复使用，从而减少开发工作量和错误率。

# 架构与设计
> 在 Minotaur 中，`Actor` 模型是其重要的组成部分之一，其 `ActorSystem` 架构设计充分利用了 `Actor` 模型的优势，实现了高并发、高可扩展性和高容错性的游戏服务器。
{.is-info}

`ActorSystem` 是一个核心的重量级结构，负责管理所有的 `Actor` 及其生命周期、消息传递和调度。`ActorSystem` 提供了一个运行时环境，使得开发者可以专注于 `Actor` 的业务逻辑，而无需关心底层的并发和通信细节。

## 组成部分
`ActorSystem` 是一个高度模块化的并发计算结构，由多个关键组件组成，包括进程注册表（ProcessRegistry）、消息调度器（MessageDispatcher）、邮箱（Mailbox）、模块（Module）、监管策略（SupervisorStrategy）、持久化（Persistence）等。
每个组件各司其职，共同实现了高效的消息传递、灵活的调度策略、强大的容错与恢复机制以及全面的系统监控与配置管理。

## 层次结构
在 Minotaur 的 `ActorSystem` 中，`Actor` 的管理采用树状结构（Tree structure），每个 `Actor` 都有一个父 `Actor` 和零个或多个子 `Actor`。这种层次结构提供了以下几个好处：
- 通过树状结构，可以方便地管理和组织 `Actor`，使得系统结构更加清晰；
- 父 `Actor` 可以负责管理其子 `Actor` 的生命周期，包括创建、停止和监督（Supervision）；
- 错误和异常可以沿着树状结构传播，父 `Actor` 可以根据需要对子 `Actor` 的错误进行处理和恢复；
- 无锁高效的完成对子 `Actor` 的创建及销毁；

我们可以通过这张图片看出来 `ActorSystem` 的层次关系。

![actor-system-tree.png](/actor-system-tree.png)


